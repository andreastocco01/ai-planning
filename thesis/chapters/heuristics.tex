\chapter{Proposed Approaches}
\label{ch:heuristics}
Heuristics are algorithms to determine a near-optimal solution to a problem. In certain scenarios,
exact methods aren't able to provide the optimal solution in a reasonable amount of time or they can't find it
at all. In contrast, a heuristic is generally capable of offering a solution that is more or less close to
the optimal one.
While there is no assurance regarding the optimality of the provided solution, it may still be considered
acceptable in some instances.
This chapter focuses on explaining the algorithms developed, while the following one presents their evaluation.\\
Before diving into the topic, it is important to understand some of the functions used by all the algorithms.
An action, in order to be eligible for application, must have all its preconditions satisfied in the current state.
If even one precondition is not satisfied, the entire action cannot be applied.
Algorithm \ref{alg:getPossibleActions} shows the pseudocode for this function.

\begin{algorithm}
	\caption{Get Possible Actions}
	\label{alg:getPossibleActions}
	\hspace*{0.5em} \textbf{Output}: $possibleActions$
	\begin{algorithmic}[1]
		\Procedure{getPossibleActions}{$currentState, planningTask$}
		\State $possibleActions \gets [\ ]$
		\ForAll{$action \in planningTask.actions$}
		\For{$i \gets 0$ to $\Call{size}{action.preconditions}$}
		\If {$action.preconditions[i] \notin currentState$}
		\State $break$
		\EndIf
		\EndFor
		\If {$i == \Call{size}{action.preconditions}$}
		\State \Call{append}{$possibleActions$, $action$}
		\EndIf
		\EndFor
		\State \textbf{return} $possibleActions$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

It scans all the actions in the planning task, and for each one, it scans all its preconditions.
If at least one precondition is not satisfied, the action will not be returned.
Additionally, applying an action means adding its effects to the current state.
The pseudocode for this function is shown in Algorithm \ref{alg:apply}.

\begin{algorithm}
	\caption{Apply}
	\label{alg:apply}
	\hspace*{0.5em} \textbf{Output}: $newState$
	\begin{algorithmic}[1]
		\Procedure{apply}{$currentState, actionToApply$}
		\State $newState \gets \Call{copy}{currentState}$
		\ForAll{$fact \in actionToApply.effects$}
		\If{$fact \notin newState$}
		\State $newState \gets newState \cup \{fact\}$
		\EndIf
		\EndFor
		\State \textbf{return} $newState$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\section{Random}
This is the simplest algorithm implemented, and it is used as a baseline for the evaluation.
At each iteration, it applies a random action from the applicable ones.
It is not a sophisticated or informed solution but this strategy can be useful
in some cases because, by chance, a good plan may be found.
Algorithm \ref{alg:random} shows the pseudocode for it.

\begin{algorithm}
	\caption{Random}
	\label{alg:random}
	\hspace*{0.5em} \textbf{Output}: $solution$
	\begin{algorithmic}[1]
		\Procedure{random}{$planningTask$}
		\State $currentState \gets planningTask.initialState$
		\State $solution \gets [\ ]$ \Comment{Initialize empty solution}
		\While {$currentState \neq planningTask.goalState$}
		\State $possibleActions \gets \Call{getPossibleActions}{currentState, planningTask}$
		\If {$\Call{empty}{possibleActions}$}
		\State \textbf{return} $failure$ \Comment{Infeasible problem}
		\EndIf
		\State $actionToApply \gets \Call{randomChoice}{possibleActions}$
		\State $currentState \gets \Call{apply}{currentState, actionToApply}$
		\State \Call{append}{$solution$, $actionToApply$}
		\EndWhile
		\State \textbf{return} $solution$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

It is important to notice that if \textit{posissibleActions} is empty, then
a solution to the planning task cannot exist. As said in Chapter \ref{ch:intro},
the problems are Delete-Free—once a fact becomes true in the current state, it remains
true until the end.
Therefore, if there are no actions to apply, it does not mean that the algorithm has reached
a dead end that could be avoided by applying different actions in a different order.
Rather, it indicates that no sequence of actions can lead to the goal state, and therefore no plan exists.
The natural evolution of this approach is to avoid choosing randomly the next action to apply and, instead, use
a strategy to select the action that is more likely to lead to a better plan.

\section{Greedy}
A greedy algorithm is a heuristic that attempts to find an optimal solution by selecting the locally
best possible choice at each iteration. For instance, in our case, the next action to apply will
always be the one with the minimum cost. In the case of a tie, a random action among those with the same cost
will be chosen.
Algorithm \ref{alg:greedy} shows the pseudocode for this algorithm. The omitted parts are identical to those in Algorithm \ref{alg:random}.

\begin{algorithm}
	\caption{Greedy}
	\label{alg:greedy}
	\hspace*{0.5em} \textbf{Output}: $solution$
	\begin{algorithmic}[1]
		\Procedure{greedy}{$planningTask$}
		\State \dots
		\State $possibleActions \gets \Call{getPossibleActions}{currentState, planningTask}$
		\If {$\Call{empty}{possibleActions}$}
		\State \textbf{return} $failure$
		\EndIf
		\State $actionToApply \gets \Call{minimumCostAction}{possibleActions}$
		\State \dots
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Instead of randomly choosing the next action to apply, here the action with minimum cost is always selected.

\section{Revised Max Heuristic}
The max heuristic is one of the most well-known delete-relaxation heuristics in the literature.
It is an \textit{admissible} heuristic, meaning that it never overestimates the cost of reaching the goal.
It assigns an heuristic cost to each action based on Equation \ref{eq:hmax} and \ref{eq:cost}

\begin{equation}
	\label{eq:hmax}
	h_{max}\left(p;s\right) \coloneqq \begin{cases}
		0                                                                & \text{if $p \in s$} \\
		\text{min}_{a \in O\left(p\right)}\left[h\left(a;s\right)\right] & \text{otherwise}
	\end{cases}
\end{equation}

where $h_{max}\left(p;s\right)$ stands for an estimate of the cost of achieving the fact \textit{p} from
the current state \textit{s}, $O\left(p\right)$ is the set of actions $\{a \in A \mid p \in \textit{eff(a)}\}$, and

\begin{equation}
	\label{eq:cost}
	h\left(a;s\right) \coloneqq cost(a) + \text{max}_{q \in pre\left(a\right)} \left[h(q, s)\right]
\end{equation}

stands for the cost of achieving the preconditions of an action \textit{a} and applying it.\\
The idea behind the use of this heuristic is similar to that of the greedy approach.
While in the greedy approach the action with the minimum actual cost is chosen, in this case,
the action with the minimum heuristic cost is selected at each iteration.
This thesis presents an implementation of the max heuristic that goes a step further.
By definition, any action applicable in the current state has a heuristic cost equal to
its own cost, since all its preconditions are satisfied—regardless of whether the action is
actually useful for reaching the goal state or not.
The implemented version performs a technique called \textit{pruning}, which consists of assigning
an infinite cost to useless actions—indicating that these actions are not helpful in finding a good plan.
When selecting a new action to apply, the useless actions are assigned an infinite cost (and are therefore discarded),
while the remaining actions retain their correct heuristic cost.
The pseudocode for this algorithm is presented in Algorithm \ref{alg:hmax}.

\begin{algorithm}
	\caption{Max Heuristic}
	\label{alg:hmax}
	\hspace*{0.5em} \textbf{Output}: $minHcost$
	\begin{algorithmic}[1]
		\Procedure{hmax}{$currentState, fact$}
		\If {$fact \in currentState$}
		\State \textbf{return} 0 \Comment{Base case}
		\EndIf
		\State $actions \gets \{a \in A \mid fact \in \textit{eff(a)}\}$ \Comment{Get all the actions having \textit{fact} as effect}
		\If {$\Call{empty}{actions}$}
		\State \textbf{return} $+\infty$ \Comment{The fact is unreachable}
		\EndIf
		\State $minHcost \gets +\infty$
		\ForAll{$action\in actions$}
		\State $maxCost \gets 0$
		\ForAll {$pre \in action.preconditions$}
		\State $maxCost \gets \Call{max}{maxCost, \Call{hmax}{currentState, pre}}$
		\EndFor
		\State $action.hCost \gets action.cost + maxCost$
		\State $minHcost \gets \Call{min}{minHcost, action.hCost}$
		\EndFor
		\State \textbf{return} $minHcost$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
