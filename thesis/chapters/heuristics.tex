\chapter{Proposed Approaches}
\label{ch:heuristics}
Heuristics are algorithms to determine a near-optimal solution to a problem. In certain scenarios,
exact methods aren't able to provide the optimal solution in a reasonable amount of time or they can't find it
at all. In contrast, a heuristic is generally capable of offering a solution that is more or less close to
the optimal one.
While there is no assurance regarding the optimality of the provided solution, it may still be considered
acceptable in some instances.
This chapter focuses on explaining the algorithms developed, while the following one presents their evaluation.\\
Before diving into the topic, it is important to understand some of the functions used by all the algorithms.
An action, in order to be eligible for application, must have all its preconditions satisfied in the current state.
If even one precondition is not satisfied, the entire action cannot be applied.
Algorithm \ref{alg:getPossibleActions} shows the pseudocode for this function

\begin{algorithm}
	\caption{Get Possible Actions}
	\label{alg:getPossibleActions}
	\hspace*{0.5em} \textbf{Output}: $possibleActions$
	\begin{algorithmic}[1]
		\Procedure{getPossibleActions}{$currentState, planningTask$}
		\State $possibleActions \gets [\ ]$
		\ForAll{$action \in planningTask.actions$}
		\For{$i \gets 0$ to $\Call{size}{action.preconditions}$}
		\If {$action.preconditions[i] \notin currentState$}
		\State $break$
		\EndIf
		\EndFor
		\If {$i == \Call{size}{action.preconditions}$}
		\State \Call{append}{$possibleActions$, $action$}
		\EndIf
		\EndFor
		\State \textbf{return} $possibleActions$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

It scans all the actions in the planning task, and for each one, it scans all its preconditions.
If at least one precondition is not satisfied, the action will not be returned.
Additionally, applying an action means adding its effects to the current state.
The pseudocode for this function is shown in Algorithm \ref{alg:apply}.

\begin{algorithm}
	\caption{Apply}
	\label{alg:apply}
	\hspace*{0.5em} \textbf{Output}: $newState$
	\begin{algorithmic}[1]
		\Procedure{apply}{$currentState, actionToApply$}
		\State $newState \gets \Call{copy}{currentState}$
		\ForAll{$fact \in actionToApply.effects$}
		\If{$fact \notin newState$}
		\State $newState \gets newState \cup \{fact\}$
		\EndIf
		\EndFor
		\State \textbf{return} $newState$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\section{Random}
This is the simplest algorithm implemented, and it is used as a baseline for the evaluation.
At each iteration, it applies a random action from the applicable ones.
It is not a sophisticated or informed solution but this strategy can be useful
in some cases because, by chance, a good plan may be found.
Algorithm \ref{alg:random} shows the pseudocode for it.

\begin{algorithm}
	\caption{Random}
	\label{alg:random}
	\hspace*{0.5em} \textbf{Output}: $solution$
	\begin{algorithmic}[1]
		\Procedure{random}{$planningTask$}
		\State $currentState \gets planningTask.initialState$
		\State $solution \gets [\ ]$ \Comment{Initialize empty solution}
		\While {$currentState \neq planningTask.goalState$}
		\State $possibleActions \gets \Call{getPossibleActions}{currentState, planningTask}$
		\If {$\Call{empty}{possibleActions}$}
		\State \textbf{return} $failure$ \Comment{Infeasible problem}
		\EndIf
		\State $actionToApply \gets \Call{randomChoice}{possibleActions}$
		\State $currentState \gets \Call{apply}{currentState, actionToApply}$
		\State \Call{append}{$solution$, $actionToApply$}
		\EndWhile
		\State \textbf{return} $solution$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

It is important to notice that if \textit{posissibleActions} is empty, then
a solution to the planning task cannot exist. As said in Chapter \ref{ch:intro},
the problems are Delete-Freeâ€”once a fact becomes true in the current state, it remains
true until the end.
Therefore, if there are no actions to apply, it does not mean that the algorithm has reached
a dead end that could be avoided by applying different actions in a different order.
Rather, it indicates that no sequence of actions can lead to the goal state, and therefore no plan exists.
The natural evolution of this approach is to avoid choosing randomly the next action to apply and, instead, use
a strategy to select the action that is more likely to lead to a better plan.

\section{Greedy}
A greedy algorithm is a heuristic that attempts to find an optimal solution by selecting the locally
best possible choice at each iteration. For instance, in our case, the next action to apply will
always be the one with the minimum cost. In the case of a tie, a random action among those with the same cost
will be chosen.
Algorithm \ref{alg:greedy} shows the pseudocode for this algorithm. The omitted parts are identical to those in Algorithm \ref{alg:random}.

\begin{algorithm}
	\caption{Greedy}
	\label{alg:greedy}
	\hspace*{0.5em} \textbf{Output}: $solution$
	\begin{algorithmic}[1]
		\Procedure{greedy}{$planningTask$}
		\State \dots
		\State $possibleActions \gets \Call{getPossibleActions}{currentState, planningTask}$
		\If {$\Call{empty}{possibleActions}$}
		\State \textbf{return} $failure$
		\EndIf
		\State $actionToApply \gets \Call{minimumCostAction}{possibleActions}$
		\State \dots
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Instead of randomly choosing the next action to apply, here the action with minimum cost is always selected.
